import { create } from 'zustand'
import { immer } from 'zustand/middleware/immer'

export interface Message {
  id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  timestamp: Date
  status?: 'pending' | 'streaming' | 'complete' | 'error'
  toolCalls?: ToolCall[]
}

export interface ToolCall {
  id: string
  name: string
  status: 'pending' | 'running' | 'complete' | 'error'
  input?: Record<string, unknown>
  output?: string
}

export interface Chat {
  id: string
  title: string
  messages: Message[]
  createdAt: Date
  updatedAt: Date
}

export interface FileNode {
  id: string
  name: string
  path: string
  type: 'file' | 'folder'
  children?: FileNode[]
  content?: string
  language?: string
}

export interface Task {
  id: string
  title: string
  status: 'pending' | 'running' | 'complete' | 'error'
  progress?: number
  output?: string
}

export interface HistoryEntry {
  id: string
  type: 'file_create' | 'file_edit' | 'file_delete' | 'command'
  description: string
  timestamp: Date
  data: Record<string, unknown>
  undone?: boolean
}

type AppView = 'chat' | 'company-wizard' | 'company-dashboard' | 'autonomous-agents' | 'self-annealing'

interface AppState {
  // UI State
  sidebarOpen: boolean
  workspaceOpen: boolean
  settingsOpen: boolean
  activeTab: 'browser' | 'tasks' | 'preview' | 'code' | 'terminal' | 'files'
  currentView: AppView

  // Chat State
  chats: Chat[]
  activeChat: string | null
  isStreaming: boolean

  // Workspace State
  files: FileNode[]
  activeFile: string | null
  previewUrl: string | null
  generatedCode: string | null  // HTML/code generated by AI for live preview

  // Task State
  tasks: Task[]

  // History for Undo/Redo
  history: HistoryEntry[]
  historyIndex: number

  // Actions
  toggleSidebar: () => void
  toggleWorkspace: () => void
  toggleSettings: () => void
  setActiveTab: (tab: 'browser' | 'tasks' | 'preview' | 'code' | 'terminal' | 'files') => void
  setView: (view: AppView) => void

  // Chat Actions
  createChat: () => void
  setActiveChat: (id: string) => void
  addMessage: (chatId: string, message: Omit<Message, 'id' | 'timestamp'>) => void
  updateMessage: (chatId: string, messageId: string, updates: Partial<Message>) => void
  setStreaming: (streaming: boolean) => void

  // File Actions
  setFiles: (files: FileNode[]) => void
  setActiveFile: (path: string | null) => void
  updateFileContent: (path: string, content: string) => void
  setPreviewUrl: (url: string | null) => void
  setGeneratedCode: (code: string | null) => void

  // Task Actions
  addTask: (task: Omit<Task, 'id'>) => void
  updateTask: (id: string, updates: Partial<Task>) => void
  removeTask: (id: string) => void

  // History Actions
  addHistory: (entry: Omit<HistoryEntry, 'id' | 'timestamp'>) => void
  undo: () => void
  redo: () => void
  canUndo: () => boolean
  canRedo: () => boolean
}

export const useAppStore = create<AppState>()(
  immer((set, get) => ({
    // Initial State
    sidebarOpen: true,
    workspaceOpen: true,
    settingsOpen: false,
    activeTab: 'browser',
    currentView: 'chat',

    chats: [],
    activeChat: null,
    isStreaming: false,

    files: [],
    activeFile: null,
    previewUrl: null,
    generatedCode: null,

    tasks: [],

    history: [],
    historyIndex: -1,

    // UI Actions
    toggleSidebar: () => set(state => { state.sidebarOpen = !state.sidebarOpen }),
    toggleWorkspace: () => set(state => { state.workspaceOpen = !state.workspaceOpen }),
    toggleSettings: () => set(state => { state.settingsOpen = !state.settingsOpen }),
    setActiveTab: (tab) => set(state => { state.activeTab = tab }),
    setView: (view) => set(state => { state.currentView = view }),

    // Chat Actions
    createChat: () => set(state => {
      const newChat: Chat = {
        id: crypto.randomUUID(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      }
      state.chats.unshift(newChat)
      state.activeChat = newChat.id
    }),

    setActiveChat: (id) => set(state => { state.activeChat = id }),

    addMessage: (chatId, message) => set(state => {
      const chat = state.chats.find(c => c.id === chatId)
      if (chat) {
        chat.messages.push({
          ...message,
          id: crypto.randomUUID(),
          timestamp: new Date(),
        })
        chat.updatedAt = new Date()
        // Update title from first user message
        if (chat.messages.length === 1 && message.role === 'user') {
          chat.title = message.content.slice(0, 50) + (message.content.length > 50 ? '...' : '')
        }
      }
    }),

    updateMessage: (chatId, messageId, updates) => set(state => {
      const chat = state.chats.find(c => c.id === chatId)
      if (chat) {
        const message = chat.messages.find(m => m.id === messageId)
        if (message) {
          Object.assign(message, updates)
        }
      }
    }),

    setStreaming: (streaming) => set(state => { state.isStreaming = streaming }),

    // File Actions
    setFiles: (files) => set(state => { state.files = files }),
    setActiveFile: (path) => set(state => { state.activeFile = path }),

    updateFileContent: (path, content) => set(state => {
      const findAndUpdate = (nodes: FileNode[]): boolean => {
        for (const node of nodes) {
          if (node.path === path) {
            node.content = content
            return true
          }
          if (node.children && findAndUpdate(node.children)) {
            return true
          }
        }
        return false
      }
      findAndUpdate(state.files)
    }),

    setPreviewUrl: (url) => set(state => { state.previewUrl = url }),
    setGeneratedCode: (code) => set(state => {
      state.generatedCode = code
      // Auto-switch to preview tab when code is generated
      if (code) {
        state.activeTab = 'preview'
      }
    }),

    // Task Actions
    addTask: (task) => set(state => {
      state.tasks.push({ ...task, id: crypto.randomUUID() })
    }),

    updateTask: (id, updates) => set(state => {
      const task = state.tasks.find(t => t.id === id)
      if (task) {
        Object.assign(task, updates)
      }
    }),

    removeTask: (id) => set(state => {
      state.tasks = state.tasks.filter(t => t.id !== id)
    }),

    // History Actions
    addHistory: (entry) => set(state => {
      // Remove any entries after current index (for redo)
      state.history = state.history.slice(0, state.historyIndex + 1)
      state.history.push({
        ...entry,
        id: crypto.randomUUID(),
        timestamp: new Date(),
      })
      state.historyIndex = state.history.length - 1
    }),

    undo: () => set(state => {
      if (state.historyIndex >= 0) {
        const entry = state.history[state.historyIndex]
        entry.undone = true
        state.historyIndex--
        // TODO: Apply reverse operation based on entry.type
      }
    }),

    redo: () => set(state => {
      if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++
        const entry = state.history[state.historyIndex]
        entry.undone = false
        // TODO: Apply operation based on entry.type
      }
    }),

    canUndo: () => get().historyIndex >= 0,
    canRedo: () => get().historyIndex < get().history.length - 1,
  }))
)
