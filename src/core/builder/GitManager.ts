/**
 * Alabobai Builder - Git Manager
 * Built-in version control for generated projects
 *
 * Features:
 * 1. Auto-commit after successful builds
 * 2. Semantic commit messages generated by AI
 * 3. Branch management for features/fixes
 * 4. Visual diff viewer
 * 5. Rollback capabilities
 * 6. Conflict resolution assistance
 */

import { EventEmitter } from 'events';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import * as path from 'path';
import * as fs from 'fs/promises';
import { LLMClient, createLLMClient, LLMConfig } from '../llm-client.js';

const execAsync = promisify(exec);

// ============================================================================
// TYPES
// ============================================================================

export interface GitConfig {
  userName: string;
  userEmail: string;
  defaultBranch: string;
  autoCommit: boolean;
  autoCommitMessage: boolean;
  signCommits: boolean;
}

export interface Repository {
  path: string;
  isInitialized: boolean;
  currentBranch: string;
  remoteName?: string;
  remoteUrl?: string;
  status: RepoStatus;
  branches: BranchInfo[];
}

export interface RepoStatus {
  clean: boolean;
  staged: FileChange[];
  unstaged: FileChange[];
  untracked: string[];
  ahead: number;
  behind: number;
  conflicts: ConflictInfo[];
}

export interface FileChange {
  path: string;
  status: ChangeStatus;
  oldPath?: string; // For renames
  additions: number;
  deletions: number;
}

export type ChangeStatus =
  | 'added'
  | 'modified'
  | 'deleted'
  | 'renamed'
  | 'copied'
  | 'untracked';

export interface BranchInfo {
  name: string;
  current: boolean;
  upstream?: string;
  lastCommit: CommitInfo;
  ahead: number;
  behind: number;
}

export interface CommitInfo {
  hash: string;
  shortHash: string;
  message: string;
  author: string;
  email: string;
  date: Date;
  files: string[];
}

export interface ConflictInfo {
  file: string;
  ours: string;
  theirs: string;
  base?: string;
  resolved: boolean;
}

export interface DiffResult {
  files: FileDiff[];
  stats: DiffStats;
}

export interface FileDiff {
  path: string;
  oldPath?: string;
  status: ChangeStatus;
  hunks: DiffHunk[];
}

export interface DiffHunk {
  oldStart: number;
  oldLines: number;
  newStart: number;
  newLines: number;
  content: string;
  changes: DiffLine[];
}

export interface DiffLine {
  type: 'add' | 'remove' | 'context';
  lineOld?: number;
  lineNew?: number;
  content: string;
}

export interface DiffStats {
  filesChanged: number;
  insertions: number;
  deletions: number;
}

export interface CommitOptions {
  message?: string;
  autoMessage?: boolean;
  stage?: string[];
  stageAll?: boolean;
  amend?: boolean;
  allowEmpty?: boolean;
}

export interface PushOptions {
  remote?: string;
  branch?: string;
  force?: boolean;
  setUpstream?: boolean;
  tags?: boolean;
}

export interface PullOptions {
  remote?: string;
  branch?: string;
  rebase?: boolean;
  autostash?: boolean;
}

export interface MergeOptions {
  branch: string;
  noFf?: boolean;
  squash?: boolean;
  message?: string;
}

// ============================================================================
// GIT MANAGER
// ============================================================================

export class GitManager extends EventEmitter {
  private llm: LLMClient;
  private config: GitConfig;
  private repos: Map<string, Repository>;

  constructor(config?: Partial<GitConfig>, llmConfig?: LLMConfig) {
    super();
    this.llm = llmConfig
      ? createLLMClient(llmConfig)
      : createLLMClient({
          provider: 'anthropic',
          apiKey: process.env.ANTHROPIC_API_KEY || '',
          model: 'claude-sonnet-4-20250514',
        });
    this.config = {
      userName: 'Alabobai Builder',
      userEmail: 'builder@alabobai.com',
      defaultBranch: 'main',
      autoCommit: true,
      autoCommitMessage: true,
      signCommits: false,
      ...config,
    };
    this.repos = new Map();
  }

  /**
   * Initialize a new Git repository
   */
  async init(projectPath: string): Promise<Repository> {
    await this.executeGit(projectPath, 'init');
    await this.executeGit(
      projectPath,
      `config user.name "${this.config.userName}"`
    );
    await this.executeGit(
      projectPath,
      `config user.email "${this.config.userEmail}"`
    );

    // Create initial commit with .gitignore
    const gitignore = this.generateGitignore();
    await fs.writeFile(path.join(projectPath, '.gitignore'), gitignore);
    await this.executeGit(projectPath, 'add .gitignore');
    await this.executeGit(projectPath, 'commit -m "Initial commit"');

    const repo = await this.getRepository(projectPath);
    this.repos.set(projectPath, repo);

    this.emit('repo-initialized', { path: projectPath, repo });
    return repo;
  }

  /**
   * Get repository information
   */
  async getRepository(projectPath: string): Promise<Repository> {
    const isInitialized = await this.isGitRepo(projectPath);

    if (!isInitialized) {
      return {
        path: projectPath,
        isInitialized: false,
        currentBranch: '',
        status: {
          clean: true,
          staged: [],
          unstaged: [],
          untracked: [],
          ahead: 0,
          behind: 0,
          conflicts: [],
        },
        branches: [],
      };
    }

    const [currentBranch, status, branches] = await Promise.all([
      this.getCurrentBranch(projectPath),
      this.getStatus(projectPath),
      this.getBranches(projectPath),
    ]);

    const remoteInfo = await this.getRemoteInfo(projectPath);

    const repo: Repository = {
      path: projectPath,
      isInitialized: true,
      currentBranch,
      ...remoteInfo,
      status,
      branches,
    };

    this.repos.set(projectPath, repo);
    return repo;
  }

  /**
   * Get current status of the repository
   */
  async getStatus(projectPath: string): Promise<RepoStatus> {
    const statusOutput = await this.executeGit(
      projectPath,
      'status --porcelain=v1'
    );

    const staged: FileChange[] = [];
    const unstaged: FileChange[] = [];
    const untracked: string[] = [];

    const lines = statusOutput.split('\n').filter(Boolean);

    for (const line of lines) {
      const index = line[0];
      const worktree = line[1];
      const filePath = line.substring(3).trim();

      if (index === '?' && worktree === '?') {
        untracked.push(filePath);
      } else {
        if (index !== ' ' && index !== '?') {
          staged.push({
            path: filePath,
            status: this.parseStatusCode(index),
            additions: 0,
            deletions: 0,
          });
        }
        if (worktree !== ' ' && worktree !== '?') {
          unstaged.push({
            path: filePath,
            status: this.parseStatusCode(worktree),
            additions: 0,
            deletions: 0,
          });
        }
      }
    }

    // Get ahead/behind counts
    let ahead = 0;
    let behind = 0;
    try {
      const counts = await this.executeGit(
        projectPath,
        'rev-list --left-right --count @{upstream}...HEAD'
      );
      const [behindStr, aheadStr] = counts.trim().split(/\s+/);
      behind = parseInt(behindStr) || 0;
      ahead = parseInt(aheadStr) || 0;
    } catch {
      // No upstream configured
    }

    // Check for conflicts
    const conflicts = await this.getConflicts(projectPath);

    return {
      clean: staged.length === 0 && unstaged.length === 0 && untracked.length === 0,
      staged,
      unstaged,
      untracked,
      ahead,
      behind,
      conflicts,
    };
  }

  /**
   * Stage files for commit
   */
  async stage(projectPath: string, files: string[]): Promise<void> {
    for (const file of files) {
      await this.executeGit(projectPath, `add "${file}"`);
    }
    this.emit('files-staged', { path: projectPath, files });
  }

  /**
   * Stage all changes
   */
  async stageAll(projectPath: string): Promise<void> {
    await this.executeGit(projectPath, 'add -A');
    this.emit('all-staged', { path: projectPath });
  }

  /**
   * Unstage files
   */
  async unstage(projectPath: string, files: string[]): Promise<void> {
    for (const file of files) {
      await this.executeGit(projectPath, `reset HEAD "${file}"`);
    }
    this.emit('files-unstaged', { path: projectPath, files });
  }

  /**
   * Create a commit
   */
  async commit(
    projectPath: string,
    options: CommitOptions = {}
  ): Promise<CommitInfo> {
    // Stage files if specified
    if (options.stageAll) {
      await this.stageAll(projectPath);
    } else if (options.stage && options.stage.length > 0) {
      await this.stage(projectPath, options.stage);
    }

    // Generate message if needed
    let message = options.message;
    if (!message && options.autoMessage !== false && this.config.autoCommitMessage) {
      message = await this.generateCommitMessage(projectPath);
    }

    if (!message) {
      throw new Error('Commit message is required');
    }

    // Build commit command
    let command = 'commit';
    if (options.amend) command += ' --amend';
    if (options.allowEmpty) command += ' --allow-empty';
    command += ` -m "${message.replace(/"/g, '\\"')}"`;

    await this.executeGit(projectPath, command);

    // Get the commit info
    const commitInfo = await this.getLastCommit(projectPath);

    this.emit('committed', { path: projectPath, commit: commitInfo });
    return commitInfo;
  }

  /**
   * Generate a commit message using AI
   */
  async generateCommitMessage(projectPath: string): Promise<string> {
    const diff = await this.getDiff(projectPath, { staged: true });

    if (diff.files.length === 0) {
      return 'Empty commit';
    }

    const systemPrompt = `You are a commit message generator. Generate a concise, semantic commit message following conventional commits format.

Format: <type>(<scope>): <description>

Types: feat, fix, docs, style, refactor, test, chore

Rules:
1. Keep under 72 characters
2. Use imperative mood ("add" not "added")
3. No period at the end
4. Be specific but concise`;

    const diffSummary = diff.files
      .map((f) => `${f.status}: ${f.path}`)
      .join('\n');

    const response = await this.llm.chat([
      { role: 'system', content: systemPrompt },
      {
        role: 'user',
        content: `Generate a commit message for these changes:\n\n${diffSummary}\n\nStats: ${diff.stats.insertions} insertions, ${diff.stats.deletions} deletions`,
      },
    ]);

    return response.trim().replace(/^["']|["']$/g, '');
  }

  /**
   * Get diff
   */
  async getDiff(
    projectPath: string,
    options: { staged?: boolean; commit?: string } = {}
  ): Promise<DiffResult> {
    let command = 'diff --numstat';
    if (options.staged) {
      command = 'diff --cached --numstat';
    } else if (options.commit) {
      command = `diff ${options.commit}^..${options.commit} --numstat`;
    }

    const numstat = await this.executeGit(projectPath, command);
    const files: FileDiff[] = [];
    let totalInsertions = 0;
    let totalDeletions = 0;

    for (const line of numstat.split('\n').filter(Boolean)) {
      const [additions, deletions, filePath] = line.split('\t');
      const add = parseInt(additions) || 0;
      const del = parseInt(deletions) || 0;
      totalInsertions += add;
      totalDeletions += del;

      files.push({
        path: filePath,
        status: 'modified',
        hunks: [],
      });
    }

    return {
      files,
      stats: {
        filesChanged: files.length,
        insertions: totalInsertions,
        deletions: totalDeletions,
      },
    };
  }

  /**
   * Get commit log
   */
  async getLog(
    projectPath: string,
    options: { limit?: number; branch?: string } = {}
  ): Promise<CommitInfo[]> {
    const limit = options.limit || 20;
    const branch = options.branch || 'HEAD';

    const format = '%H|%h|%s|%an|%ae|%aI';
    const output = await this.executeGit(
      projectPath,
      `log ${branch} -${limit} --format="${format}"`
    );

    const commits: CommitInfo[] = [];

    for (const line of output.split('\n').filter(Boolean)) {
      const [hash, shortHash, message, author, email, dateStr] = line.split('|');
      commits.push({
        hash,
        shortHash,
        message,
        author,
        email,
        date: new Date(dateStr),
        files: [],
      });
    }

    return commits;
  }

  /**
   * Create a new branch
   */
  async createBranch(
    projectPath: string,
    branchName: string,
    checkout: boolean = true
  ): Promise<void> {
    await this.executeGit(projectPath, `branch "${branchName}"`);
    if (checkout) {
      await this.executeGit(projectPath, `checkout "${branchName}"`);
    }
    this.emit('branch-created', { path: projectPath, branch: branchName });
  }

  /**
   * Switch to a branch
   */
  async checkout(
    projectPath: string,
    branchName: string,
    create: boolean = false
  ): Promise<void> {
    const flag = create ? '-b' : '';
    await this.executeGit(projectPath, `checkout ${flag} "${branchName}"`);
    this.emit('branch-switched', { path: projectPath, branch: branchName });
  }

  /**
   * Delete a branch
   */
  async deleteBranch(
    projectPath: string,
    branchName: string,
    force: boolean = false
  ): Promise<void> {
    const flag = force ? '-D' : '-d';
    await this.executeGit(projectPath, `branch ${flag} "${branchName}"`);
    this.emit('branch-deleted', { path: projectPath, branch: branchName });
  }

  /**
   * Merge a branch
   */
  async merge(projectPath: string, options: MergeOptions): Promise<void> {
    let command = `merge "${options.branch}"`;
    if (options.noFf) command += ' --no-ff';
    if (options.squash) command += ' --squash';
    if (options.message) command += ` -m "${options.message}"`;

    try {
      await this.executeGit(projectPath, command);
      this.emit('merged', { path: projectPath, branch: options.branch });
    } catch (error) {
      // Check for conflicts
      const conflicts = await this.getConflicts(projectPath);
      if (conflicts.length > 0) {
        this.emit('merge-conflict', { path: projectPath, conflicts });
        throw new Error(`Merge conflict in ${conflicts.length} file(s)`);
      }
      throw error;
    }
  }

  /**
   * Push to remote
   */
  async push(projectPath: string, options: PushOptions = {}): Promise<void> {
    const remote = options.remote || 'origin';
    let branch = options.branch || (await this.getCurrentBranch(projectPath));

    let command = `push ${remote} ${branch}`;
    if (options.force) command += ' --force';
    if (options.setUpstream) command += ' -u';
    if (options.tags) command += ' --tags';

    await this.executeGit(projectPath, command);
    this.emit('pushed', { path: projectPath, remote, branch });
  }

  /**
   * Pull from remote
   */
  async pull(projectPath: string, options: PullOptions = {}): Promise<void> {
    const remote = options.remote || 'origin';
    const branch = options.branch || (await this.getCurrentBranch(projectPath));

    let command = `pull ${remote} ${branch}`;
    if (options.rebase) command += ' --rebase';
    if (options.autostash) command += ' --autostash';

    try {
      await this.executeGit(projectPath, command);
      this.emit('pulled', { path: projectPath, remote, branch });
    } catch (error) {
      const conflicts = await this.getConflicts(projectPath);
      if (conflicts.length > 0) {
        this.emit('pull-conflict', { path: projectPath, conflicts });
        throw new Error(`Pull conflict in ${conflicts.length} file(s)`);
      }
      throw error;
    }
  }

  /**
   * Add a remote
   */
  async addRemote(
    projectPath: string,
    name: string,
    url: string
  ): Promise<void> {
    await this.executeGit(projectPath, `remote add ${name} "${url}"`);
    this.emit('remote-added', { path: projectPath, name, url });
  }

  /**
   * Rollback to a specific commit
   */
  async rollback(
    projectPath: string,
    commitHash: string,
    options: { soft?: boolean; hard?: boolean } = {}
  ): Promise<void> {
    let mode = '--mixed';
    if (options.soft) mode = '--soft';
    if (options.hard) mode = '--hard';

    await this.executeGit(projectPath, `reset ${mode} ${commitHash}`);
    this.emit('rollback', { path: projectPath, commit: commitHash, mode });
  }

  /**
   * Stash changes
   */
  async stash(
    projectPath: string,
    message?: string
  ): Promise<void> {
    let command = 'stash push';
    if (message) command += ` -m "${message}"`;

    await this.executeGit(projectPath, command);
    this.emit('stashed', { path: projectPath, message });
  }

  /**
   * Pop stashed changes
   */
  async stashPop(projectPath: string): Promise<void> {
    await this.executeGit(projectPath, 'stash pop');
    this.emit('stash-popped', { path: projectPath });
  }

  /**
   * Resolve a conflict by choosing a side
   */
  async resolveConflict(
    projectPath: string,
    file: string,
    resolution: 'ours' | 'theirs' | 'merged',
    mergedContent?: string
  ): Promise<void> {
    if (resolution === 'merged' && mergedContent) {
      await fs.writeFile(path.join(projectPath, file), mergedContent);
    } else {
      await this.executeGit(projectPath, `checkout --${resolution} "${file}"`);
    }

    await this.executeGit(projectPath, `add "${file}"`);
    this.emit('conflict-resolved', { path: projectPath, file, resolution });
  }

  /**
   * Get AI assistance for resolving a conflict
   */
  async getConflictResolutionHelp(
    projectPath: string,
    conflict: ConflictInfo
  ): Promise<string> {
    const systemPrompt = `You are a merge conflict resolution expert. Analyze the conflict and provide a merged solution that preserves the intent of both changes.

Return the merged code that resolves the conflict, without conflict markers.`;

    const userPrompt = `Resolve this merge conflict:

Ours (current branch):
${conflict.ours}

Theirs (incoming branch):
${conflict.theirs}

${conflict.base ? `Common ancestor:\n${conflict.base}` : ''}`;

    return await this.llm.chat([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ]);
  }

  // ==========================================================================
  // PRIVATE METHODS
  // ==========================================================================

  private async executeGit(
    projectPath: string,
    command: string
  ): Promise<string> {
    try {
      const { stdout } = await execAsync(`git ${command}`, {
        cwd: projectPath,
        maxBuffer: 10 * 1024 * 1024,
      });
      return stdout.trim();
    } catch (error) {
      const execError = error as { stderr?: string; message?: string };
      throw new Error(execError.stderr || execError.message || 'Git command failed');
    }
  }

  private async isGitRepo(projectPath: string): Promise<boolean> {
    try {
      await this.executeGit(projectPath, 'rev-parse --git-dir');
      return true;
    } catch {
      return false;
    }
  }

  private async getCurrentBranch(projectPath: string): Promise<string> {
    try {
      return await this.executeGit(projectPath, 'branch --show-current');
    } catch {
      return 'HEAD';
    }
  }

  private async getBranches(projectPath: string): Promise<BranchInfo[]> {
    const output = await this.executeGit(
      projectPath,
      'branch -a --format="%(refname:short)|%(upstream:short)|%(objectname:short)|%(subject)|%(authorname)|%(authoremail)|%(committerdate:iso)"'
    );

    const branches: BranchInfo[] = [];
    const currentBranch = await this.getCurrentBranch(projectPath);

    for (const line of output.split('\n').filter(Boolean)) {
      const [name, upstream, shortHash, message, author, email, dateStr] =
        line.split('|');

      if (name.startsWith('remotes/')) continue;

      branches.push({
        name,
        current: name === currentBranch,
        upstream: upstream || undefined,
        lastCommit: {
          hash: shortHash,
          shortHash,
          message,
          author,
          email,
          date: new Date(dateStr),
          files: [],
        },
        ahead: 0,
        behind: 0,
      });
    }

    return branches;
  }

  private async getRemoteInfo(
    projectPath: string
  ): Promise<{ remoteName?: string; remoteUrl?: string }> {
    try {
      const remoteName = await this.executeGit(
        projectPath,
        'remote'
      );
      if (remoteName) {
        const remoteUrl = await this.executeGit(
          projectPath,
          `remote get-url ${remoteName.split('\n')[0]}`
        );
        return { remoteName: remoteName.split('\n')[0], remoteUrl };
      }
    } catch {
      // No remote configured
    }
    return {};
  }

  private async getLastCommit(projectPath: string): Promise<CommitInfo> {
    const format = '%H|%h|%s|%an|%ae|%aI';
    const output = await this.executeGit(
      projectPath,
      `log -1 --format="${format}"`
    );

    const [hash, shortHash, message, author, email, dateStr] = output.split('|');

    return {
      hash,
      shortHash,
      message,
      author,
      email,
      date: new Date(dateStr),
      files: [],
    };
  }

  private async getConflicts(projectPath: string): Promise<ConflictInfo[]> {
    const conflicts: ConflictInfo[] = [];

    try {
      const output = await this.executeGit(
        projectPath,
        'diff --name-only --diff-filter=U'
      );

      for (const file of output.split('\n').filter(Boolean)) {
        const content = await fs.readFile(
          path.join(projectPath, file),
          'utf-8'
        );

        // Parse conflict markers
        const oursMatch = content.match(/<<<<<<< .*?\n([\s\S]*?)=======/);
        const theirsMatch = content.match(/=======\n([\s\S]*?)>>>>>>> /);

        conflicts.push({
          file,
          ours: oursMatch?.[1] || '',
          theirs: theirsMatch?.[1] || '',
          resolved: false,
        });
      }
    } catch {
      // No conflicts
    }

    return conflicts;
  }

  private parseStatusCode(code: string): ChangeStatus {
    const statusMap: Record<string, ChangeStatus> = {
      A: 'added',
      M: 'modified',
      D: 'deleted',
      R: 'renamed',
      C: 'copied',
      '?': 'untracked',
    };
    return statusMap[code] || 'modified';
  }

  private generateGitignore(): string {
    return `# Dependencies
node_modules/
.pnpm-store/

# Build output
dist/
build/
.next/
.nuxt/
.output/

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
coverage/
.nyc_output/

# Cache
.cache/
.parcel-cache/
.turbo/

# Temporary files
tmp/
temp/
*.tmp
`;
  }
}

// ============================================================================
// EXPORTS
// ============================================================================

export function createGitManager(
  config?: Partial<GitConfig>,
  llmConfig?: LLMConfig
): GitManager {
  return new GitManager(config, llmConfig);
}

export default GitManager;
